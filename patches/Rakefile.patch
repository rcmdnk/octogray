diff --git a/Rakefile b/Rakefile
index 9367ea1..6fcace6 100644
--- a/Rakefile
+++ b/Rakefile
@@ -1,6 +1,8 @@
 require "rubygems"
 require "bundler/setup"
 require "stringex"
+require 'ruby-progressbar'
+require "open3"
 
 ## -- Rsync Deploy config -- ##
 # Be sure your public key is listed in your server's ~/.ssh/authorized_keys file
@@ -9,27 +11,46 @@ ssh_port       = "22"
 document_root  = "~/website.com/"
 rsync_delete   = false
 rsync_args     = ""  # Any extra arguments to pass to rsync
-deploy_default = "rsync"
+deploy_default = "push"
 
 # This will be configured for you when you run config_deploy
-deploy_branch  = "gh-pages"
+deploy_branch  = "master"
+repo_url       = "git@github.com:user/user.github.io.git"
+use_token      = false
 
 ## -- Misc Configs -- ##
 
-public_dir      = "public"    # compiled site directory
+tmp_dir         = File.expand_path(".") + "/"  # temporary directory for public/deploy
+public_dir      = "#{tmp_dir}public"  # compiled site directory
 source_dir      = "source"    # source file directory
 blog_index_dir  = 'source'    # directory for your blog's index page (if you put your index in source/blog/index.html, set this to 'source/blog')
-deploy_dir      = "_deploy"   # deploy directory (for Github pages deployment)
+deploy_dir      = "#{tmp_dir}_deploy" # deploy directory (for Github pages deployment)
 stash_dir       = "_stash"    # directory to stash posts for speedy generation
+full_stash_dir  = "#{source_dir}/#{stash_dir}"    # full path for stash dir
+stash_root_dir  = "_stash_root" # directory to stash pages (in /source/)
+full_stash_root_dir = "#{source_dir}/#{stash_root_dir}" # full path for stash_root dir
+root_stashes    = [] # directories to be stashed in /source/
 posts_dir       = "_posts"    # directory for blog files
 themes_dir      = ".themes"   # directory for blog files
 new_post_ext    = "markdown"  # default new post file extension when using the new_post task
 new_page_ext    = "markdown"  # default new page file extension when using the new_page task
 server_port     = "4000"      # port for preview server eg. localhost:4000
+word_avoid      = "~/.gitavoid"  # words which must be avoided to be published
+ping_file       = "ping.yml"  # file of site list for ping
+minify          = false
+js_for_combine  = ['footnote.js', 'jquery.githubRepoWidget.min.js', 'monthly_archive.js', 'random-posts.js', 'related-posts.js', 'utils.js']
+js_output       = "all.js"
+js_minify_others = false
+#html_for_minify = "all"
+html_for_minify = ["*.html", "blog/*/*/*/*/*.html"]
+html_not_minify = []
+precheck        = false
+n_cores         = 8
+compass         = "ruby -r ./plugins/compass_monkey_patch.rb -S compass"
 
 if (/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) != nil
   puts '## Set the codepage to 65001 for Windows machines'
-  `chcp 65001`
+  `chcp.com 65001`
 end
 
 desc "Initial setup for Octopress: copies the default theme into the path of Jekyll's generator. Rake install defaults to rake install[classic] to install a different theme run rake install[some_theme_name]"
@@ -52,47 +73,192 @@ end
 # Working with Jekyll #
 #######################
 
-desc "Generate jekyll site"
-task :generate do
+desc "Update stylesheets. Give an argument as nested, expanded, compact or compressed (default) to the output style."
+task :css, :style do |t, args|
   raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
+  puts "## Update stylesheets"
+  style = minify ? "-s compressed" : "-s nested"
+  if args.style
+    style = "-s #{args.style}"
+  end
+  ok_failed("#{compass} compile #{style} --css-dir #{source_dir}/stylesheets")
+  cp_r "#{source_dir}/stylesheets/.", "#{public_dir}/stylesheets/"
+end
+
+desc "Generate jekyll site"
+task :generate, :opt do |t, args|
+  raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
+
+  opt = args.opt ? args.opt : ""
+
+  if precheck and not opt.include?('test')
+    Rake::Task[:check].invoke()
+  end
+
   puts "## Generating Site with Jekyll"
-  system "compass compile --css-dir #{source_dir}/stylesheets"
-  system "jekyll build"
+
+  jekyll_opt = ""
+  if Rake.application.options.trace or opt.include?('test')
+    jekyll_opt = "--trace"
+  end
+  if opt.include?("unpublished") or opt.include?('test')
+    jekyll_opt += " --unpublished"
+  end
+
+  jekyll_config = IO.read('_config.yml')
+  jekyll_config.gsub!(/\n^.*OCTOPRESS_TEST$/, "")
+  File.open('_config.yml', 'w') do |f|
+    f.write jekyll_config
+  end
+
+  if opt.include?('test')
+    jekyll_config = IO.read('_config.yml')
+    jekyll_config += "\nshare_static: false # OCTOPRESS_TEST"
+    jekyll_config += "\npage-view: false # OCTOPRESS_TEST"
+    jekyll_config += "\nhatena_popular_num: 0 # OCTOPRESS_TEST"
+    File.open('_config.yml', 'w') do |f|
+      f.write jekyll_config
+    end
+  end
+
+  ok_failed("JEKYLL_ENV=production jekyll build #{jekyll_opt}")
+
+  if opt.include?('test')
+    jekyll_config = IO.read('_config.yml')
+    jekyll_config.gsub!(/\n^.*OCTOPRESS_TEST$/, "")
+    File.open('_config.yml', 'w') do |f|
+      f.write jekyll_config
+    end
+  end
+
+  Rake::Task[:css].execute
+  Rake::Task[:combine_js].invoke(args.opt)
+  if not opt.include?('test')
+    if not opt.include?('test') and minify
+      Rake::Task[:minify_js].invoke('force')
+
+      if not opt.include?('no_minify')
+        Rake::Task[:minify_html].execute
+      end
+    end
+  end
+
+  ok_failed("rm -f .integrated", false)
+  ok_failed("rm -f .preview-mode", false)
+end
+
+desc "Same as generate"
+task :gen, :opt do |t, args|
+  Rake::Task[:generate].invoke(args.opt)
+end
+
+desc "Generate test (no css, js compiling)"
+task :gen_test, :opt do |t, args|
+  Rake::Task[:generate].invoke('test')
+end
+desc "Same as gen_test"
+task :gt, :opt do |t, args|
+  Rake::Task[:gen_test].invoke()
+end
+
+# usage rake generate_only[my-post]
+desc "Generate only specified post (much faster)"
+task :generate_only, :filename do |t, args|
+  trap(:INT) do
+    raise "Stopped by SIGINT"
+  end
+  begin
+    if precheck
+      Rake::Task[:check].invoke()
+    end
+
+    Rake::Task[:isolate].invoke(args.filename)
+    Rake::Task[:generate].invoke('test')
+
+    puts "## Restoring stashed posts/pages"
+    Rake::Task[:integrate].execute
+  rescue
+    Rake::Task[:integrate].execute
+    raise $!
+  end
+end
+
+desc "Same as generate_only"
+task :gen_only, :filename do |t, args|
+  Rake::Task[:generate_only].invoke(args.filename)
+end
+
+desc "Same as generate_only"
+task :go, :filename do |t, args|
+  Rake::Task[:generate_only].invoke(args.filename)
 end
 
 desc "Watch the site and regenerate when it changes"
 task :watch do
   raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
   puts "Starting to watch source with Jekyll and Compass."
-  system "compass compile --css-dir #{source_dir}/stylesheets" unless File.exist?("#{source_dir}/stylesheets/screen.css")
-  jekyllPid = Process.spawn({"OCTOPRESS_ENV"=>"preview"}, "jekyll build --watch")
-  compassPid = Process.spawn("compass watch")
+  ok_failed("#{compass} compile --css-dir #{source_dir}/stylesheets") unless File.exist?("#{source_dir}/stylesheets/screen.css")
+  ok_failed( "touch .preview-mode")
+  jekyllPid = Process.spawn("jekyll build --watch --unpublished")
+  compassPid = Process.spawn("#{compass} watch")
 
   trap("INT") {
     [jekyllPid, compassPid].each { |pid| Process.kill(9, pid) rescue Errno::ESRCH }
-    exit 0
   }
 
   [jekyllPid, compassPid].each { |pid| Process.wait(pid) }
 end
 
+# usage rake watch_only[my-post]
+desc "watch only specified post"
+task :watch_only, :filename do |t, args|
+  raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
+  Rake::Task[:isolate].invoke(args.filename)
+
+  begin
+    Rake::Task[:watch].execute
+  rescue
+  end
+
+  puts ""
+  puts "## Restoring stashed posts/pages"
+  Rake::Task[:integrate].execute
+end
+
 desc "preview the site in a web browser"
 task :preview do
   raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
   puts "Starting to watch source with Jekyll and Compass. Starting Rack on port #{server_port}"
-  system "compass compile --css-dir #{source_dir}/stylesheets" unless File.exist?("#{source_dir}/stylesheets/screen.css")
-  jekyllPid = Process.spawn({"OCTOPRESS_ENV"=>"preview"}, "jekyll build --watch")
-  compassPid = Process.spawn("compass watch")
+  ok_failed("#{compass} compile --css-dir #{source_dir}/stylesheets") unless File.exist?("#{source_dir}/stylesheets/screen.css")
+  ok_failed("touch .preview-mode")
+  jekyllPid = Process.spawn("jekyll build --watch --unpublished")
+  compassPid = Process.spawn("#{compass} watch")
   rackupPid = Process.spawn("rackup --port #{server_port}")
 
   trap("INT") {
     [jekyllPid, compassPid, rackupPid].each { |pid| Process.kill(9, pid) rescue Errno::ESRCH }
-    exit 0
   }
 
   [jekyllPid, compassPid, rackupPid].each { |pid| Process.wait(pid) }
 end
 
+# usage rake preview_only[my-post]
+desc "preview only specified post"
+task :preview_only, :filename do |t, args|
+  raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
+  Rake::Task[:isolate].invoke(args.filename)
+
+  begin
+    Rake::Task[:preview].execute
+  rescue
+  end
+
+  puts ""
+  puts "## Restoring stashed posts/pages"
+  Rake::Task[:integrate].execute
+end
+
+
 # usage rake new_post[my-new-post] or rake new_post['my new post'] or rake new_post (defaults to "new-post")
 desc "Begin a new post in #{source_dir}/#{posts_dir}"
 task :new_post, :title do |t, args|
@@ -102,20 +268,39 @@ task :new_post, :title do |t, args|
     title = get_stdin("Enter a title for your post: ")
   end
   raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
+  title_words = title.split(' ')
+  tags = title_words
+  category = tags.shift
   mkdir_p "#{source_dir}/#{posts_dir}"
   filename = "#{source_dir}/#{posts_dir}/#{Time.now.strftime('%Y-%m-%d')}-#{title.to_url}.#{new_post_ext}"
   if File.exist?(filename)
     abort("rake aborted!") if ask("#{filename} already exists. Do you want to overwrite?", ['y', 'n']) == 'n'
   end
+  # Change title (make it for tags for some posting sites)
+  #title_tags = "\##{tags.join(' #')}"
   puts "Creating new post: #{filename}"
   open(filename, 'w') do |post|
     post.puts "---"
     post.puts "layout: post"
-    post.puts "title: \"#{title.gsub(/&/,'&amp;')}\""
-    post.puts "date: #{Time.now.strftime('%Y-%m-%d %H:%M:%S %z')}"
+    #post.puts "title: \"#{title.gsub(/&/,'&amp;')}\""
+    #post.puts "title: \"#{title_tags}\""
+    post.puts "title: \"\""
+    #post.puts "date: #{Time.now.strftime('%Y-%m-%d %H:%M:%S %z')}"
+    #post.puts "date: #{Time.now.strftime('%Y-%m-%d 12:00')}"
     post.puts "comments: true"
-    post.puts "categories: "
+    post.puts "categories: #{category}"
+    post.puts "tags: #{tags}"
+    post.puts "keywords: #{title.gsub(' ',', ')}"
+    #post.puts "description: "
+    post.puts "ogimage:"
+    post.puts "published: false"
     post.puts "---"
+    post.puts ""
+    post.puts "<!-- more -->"
+    post.puts "{% include after_excerpt.html %}"
+    post.puts ""
+    post.puts "##"
+    post.puts ""
   end
 end
 
@@ -125,8 +310,10 @@ task :new_page, :filename do |t, args|
   raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
   args.with_defaults(:filename => 'new-page')
   page_dir = [source_dir]
+  site_config = YAML.load(IO.read('_config.yml'))
+  author = site_config['author']
   if args.filename.downcase =~ /(^.+\/)?(.+)/
-    filename, dot, extension = $2.rpartition('.').reject(&:empty?)         # Get filename and extension
+    filename, extension = $2.rpartition('.').reject(&:empty?)         # Get filename and extension
     title = filename
     page_dir.concat($1.downcase.sub(/^\//, '').split('/')) unless $1.nil?  # Add path to page_dir Array
     if extension.nil?
@@ -147,10 +334,13 @@ task :new_page, :filename do |t, args|
       page.puts "---"
       page.puts "layout: page"
       page.puts "title: \"#{title}\""
-      page.puts "date: #{Time.now.strftime('%Y-%m-%d %H:%M')}"
+      page.puts "author: \"#{author}\""
+      #page.puts "date: #{Time.now.strftime('%Y-%m-%d %H:%M')}"
+      page.puts "date: #{Time.now.strftime('%Y-%m-%d 12:00')}"
       page.puts "comments: true"
       page.puts "sharing: true"
       page.puts "footer: true"
+      page.puts "published: false"
       page.puts "---"
     end
   else
@@ -161,21 +351,49 @@ end
 # usage rake isolate[my-post]
 desc "Move all other posts than the one currently being worked on to a temporary stash location (stash) so regenerating the site happens much more quickly."
 task :isolate, :filename do |t, args|
-  stash_dir = "#{source_dir}/#{stash_dir}"
-  FileUtils.mkdir(stash_dir) unless File.exist?(stash_dir)
-  Dir.glob("#{source_dir}/#{posts_dir}/*.*") do |post|
-    FileUtils.mv post, stash_dir unless post.include?(args.filename)
+  if args.filename
+    filename = args.filename
+  else
+    filename = Dir.glob("#{source_dir}/#{posts_dir}/*.#{new_post_ext}").sort_by{|f| File.mtime(f)}.last
   end
+  if filename == nil
+    puts "## Stashing all posts"
+  else
+    puts "## Stashing other posts than #{filename}"
+  end
+  FileUtils.mkdir(full_stash_dir) unless File.exist?(full_stash_dir)
+  Dir.glob("#{source_dir}/#{posts_dir}/*") do |post|
+    if filename != nil && post.include?(filename)
+      puts "Remaining #{post}..."
+    else
+      FileUtils.mv post, full_stash_dir
+    end
+  end
+  FileUtils.mkdir(full_stash_root_dir) unless File.exist?(full_stash_root_dir)
+  if defined? root_stashes == nil
+    if root_stashes.class == String
+      FileUtils.mv "#{source_dir}/#{root_stashes}", full_stash_root_dir
+    elsif root_stashes.class == Array
+      for d in root_stashes do
+        FileUtils.mv "#{source_dir}/#{d}", full_stash_root_dir if File.exist?("#{source_dir}/#{d}")
+      end
+    end
+  end
+  ok_failed("touch .isolated", false)
 end
 
 desc "Move all stashed posts back into the posts directory, ready for site generation."
 task :integrate do
-  FileUtils.mv Dir.glob("#{source_dir}/#{stash_dir}/*.*"), "#{source_dir}/#{posts_dir}/"
+  FileUtils.mv Dir.glob("#{full_stash_dir}/*"), "#{source_dir}/#{posts_dir}/"
+  FileUtils.mv Dir.glob("#{full_stash_root_dir}/*"), "#{source_dir}/"
+  ok_failed("rm -f .isolated", false)
+  ok_failed("touch .integrated", false)
 end
 
-desc "Clean out caches: .pygments-cache, .gist-cache, .sass-cache"
+desc "Clean out caches: .pygments-cache, .gist-cache, .sass-cache, thumbnail"
 task :clean do
-  rm_rf [Dir.glob(".pygments-cache/**"), Dir.glob(".gist-cache/**"), Dir.glob(".sass-cache/**"), "source/stylesheets/screen.css"]
+  rm_rf [Dir.glob(".pygments-cache/**"), Dir.glob(".gist-cache/**"), Dir.glob(".sass-cache/**"), "#{source_dir}/stylesheets/screen.css"]
+  rm_rf [Dir.glob("#{source_dir}/images/**/thumbnail")]
 end
 
 desc "Move sass to sass.old, install sass theme updates, replace sass/custom with sass.old/custom"
@@ -215,20 +433,47 @@ end
 ##############
 
 desc "Default deploy task"
-task :deploy do
-  # Check if preview posts exist, which should not be published
-  if File.exists?(".preview-mode")
+task :deploy, :deploy_method do |t, args|
+  # Check if preview posts exists, which should not be published
+  if File.exist?(".integrated") or File.exist?(".isolated")
+    puts "## Found isolated history, regenerating files ..."
+    ok_failed("rm -f .integrated .isolated", false)
+    Rake::Task[:integrate].execute
+    Rake::Task[:generate].execute
+  end
+  if File.exist?(".preview-mode")
     puts "## Found posts in preview mode, regenerating files ..."
     File.delete(".preview-mode")
     Rake::Task[:generate].execute
   end
 
   Rake::Task[:copydot].invoke(source_dir, public_dir)
-  Rake::Task["#{deploy_default}"].execute
+
+  # Check if files are fine or not
+  ok_failed("if [ -f #{word_avoid} ];then while read a;do if ret=`grep -i -r -q $a #{public_dir}`;then echo \"A word $a is included, must be avoided!!!\"; echo $ret; exit 1;fi; done < #{word_avoid};fi", false)
+
+  if args.deploy_method
+    deploy_method = args.deploy_method;
+  else
+    deploy_method = deploy_default;
+  end
+  puts "use #{deploy_method} to push"
+  Rake::Task["#{deploy_method}"].execute
+
+  Rake::Task[:ping].execute
+  Rake::Task[:superfeedr].execute
 end
 
 desc "Generate website and deploy"
-task :gen_deploy => [:integrate, :generate, :deploy] do
+task :gen_deploy, :deploy_method do |t, args|
+  Rake::Task[:integrate].execute
+  Rake::Task[:generate].execute
+  Rake::Task[:deploy].invoke(args.deploy_method)
+end
+
+desc "Same as gen_deploy"
+task :gd, :deploy_method do |t, args|
+  Rake::Task[:gen_deploy].invoke(args.deploy_method)
 end
 
 desc "copy dot files for deployment"
@@ -241,78 +486,109 @@ end
 desc "Deploy website via rsync"
 task :rsync do
   exclude = ""
-  if File.exists?('./rsync-exclude')
+  if File.exist?('./rsync-exclude')
     exclude = "--exclude-from '#{File.expand_path('./rsync-exclude')}'"
   end
   puts "## Deploying website via Rsync"
-  ok_failed system("rsync -avze 'ssh -p #{ssh_port}' #{exclude} #{rsync_args} #{"--delete" unless rsync_delete == false} #{public_dir}/ #{ssh_user}:#{document_root}")
+  ok_failed("rsync -avze 'ssh -p #{ssh_port}' #{exclude} #{rsync_args} #{"--delete" unless rsync_delete == false} #{public_dir}/ #{ssh_user}:#{document_root}", false)
 end
 
 desc "deploy public directory to github pages"
 multitask :push do
   puts "## Deploying branch to Github Pages "
   puts "## Pulling any updates from Github Pages "
-  cd "#{deploy_dir}" do 
-    Bundler.with_clean_env { system "git pull" }
+  cd "#{deploy_dir}" do
+    Bundler.with_original_env { ok_failed("git pull", false) }
   end
   (Dir["#{deploy_dir}/*"]).each { |f| rm_rf(f) }
   Rake::Task[:copydot].invoke(public_dir, deploy_dir)
   puts "\n## Copying #{public_dir} to #{deploy_dir}"
   cp_r "#{public_dir}/.", deploy_dir
   cd "#{deploy_dir}" do
-    system "git add -A"
+    ok_failed("git add -A", false)
     message = "Site updated at #{Time.now.utc}"
     puts "\n## Committing: #{message}"
-    system "git commit -m \"#{message}\""
+    ok_failed("git commit -m \"#{message}\"", false)
     puts "\n## Pushing generated #{deploy_dir} website"
-    Bundler.with_clean_env { system "git push origin #{deploy_branch}" }
+    output = (use_token)? " >/dev/null 2>&1":""
+    Bundler.with_original_env { ok_failed("git push origin #{deploy_branch} #{output}", false) }
+    puts "\n## Github Pages deploy complete"
+  end
+end
+
+desc "deploy public directory to github pages through temporary deploy dir"
+multitask :push_ex do
+  puts "## Deploying branch to Github Pages "
+  if use_token
+    puts "## clone the repository..."
+  else
+    puts "## clone from #{repo_url}"
+  end
+  rm_rf deploy_dir
+  mkdir_p deploy_dir
+  cd "#{deploy_dir}" do
+    ok_failed("git init", false)
+    ok_failed("git remote add origin #{repo_url}", false)
+  end
+
+  Rake::Task[:copydot].invoke(public_dir, deploy_dir)
+  puts "\n## Copying #{public_dir} to #{deploy_dir}"
+  cp_r "#{public_dir}/.", deploy_dir
+  cd "#{deploy_dir}" do
+    ok_failed("git add -A", false)
+    puts "\n## Commiting: Site updated at #{Time.now.utc}"
+    message = "Site updated at #{Time.now.utc}"
+    ok_failed("git commit -m \"#{message}\" >/dev/null", false)
+    ok_failed("git branch -m #{deploy_branch}", false)
+    puts "\n## Pushing generated #{deploy_dir} website"
+    output = (use_token) ? " >/dev/null 2>&1" : ""
+    Bundler.with_unbundled_env { ok_failed("git push -u -f origin #{deploy_branch} #{output}", false) }
     puts "\n## Github Pages deploy complete"
   end
 end
 
 desc "Update configurations to support publishing to root or sub directory"
 task :set_root_dir, :dir do |t, args|
-  puts ">>> !! Please provide a directory, eg. rake config_dir[publishing/subdirectory]" unless args.dir
+  puts ">>> !! Please provide a directory, eg. rake set_root_dir[publishing/subdirectory]" unless args.dir
   if args.dir
     if args.dir == "/"
-      dir = ""
+      dir = "/"
     else
-      dir = "/" + args.dir.sub(/(\/*)(.+)/, "\\2").sub(/\/$/, '');
+      dir = "/" + args.dir.sub(/(\/*)(.+)/, "\\2").sub(/\/$/, '') + "/"
     end
+    rm_rf "#{public_dir}"
     rakefile = IO.read(__FILE__)
-    rakefile.sub!(/public_dir(\s*)=(\s*)(["'])[\w\-\/]*["']/, "public_dir\\1=\\2\\3public#{dir}\\3")
+    rakefile.sub!(/public_dir(\s*)=(\s*)(["'])[^"']*public[^"']*(["'])/, "public_dir\\1=\\2\\3\#{tmp_dir}#{File.join('public', dir)}\\3")
     File.open(__FILE__, 'w') do |f|
       f.write rakefile
     end
     compass_config = IO.read('config.rb')
-    compass_config.sub!(/http_path(\s*)=(\s*)(["'])[\w\-\/]*["']/, "http_path\\1=\\2\\3#{dir}/\\3")
-    compass_config.sub!(/http_images_path(\s*)=(\s*)(["'])[\w\-\/]*["']/, "http_images_path\\1=\\2\\3#{dir}/images\\3")
-    compass_config.sub!(/http_fonts_path(\s*)=(\s*)(["'])[\w\-\/]*["']/, "http_fonts_path\\1=\\2\\3#{dir}/fonts\\3")
-    compass_config.sub!(/css_dir(\s*)=(\s*)(["'])[\w\-\/]*["']/, "css_dir\\1=\\2\\3public#{dir}/stylesheets\\3")
+    compass_config.sub!(/http_path(\s*)=(\s*)(["'])[\w\-\/]*["']/, "http_path\\1=\\2\\3#{File.join(dir, '/')}\\3")
+    compass_config.sub!(/http_images_path(\s*)=(\s*)(["'])[\w\-\/]*["']/, "http_images_path\\1=\\2\\3#{File.join(dir, '/images')}\\3")
+    compass_config.sub!(/http_fonts_path(\s*)=(\s*)(["'])[\w\-\/]*["']/, "http_fonts_path\\1=\\2\\3#{File.join(dir, '/fonts')}\\3")
+    compass_config.sub!(/css_dir(\s*)=(\s*)(["'])[\w\-\/]*["']/, "css_dir\\1=\\2\\3public#{File.join(dir, '/stylesheets')}\\3")
     File.open('config.rb', 'w') do |f|
       f.write compass_config
     end
     jekyll_config = IO.read('_config.yml')
-    jekyll_config.sub!(/^destination:.+$/, "destination: public#{dir}")
-    jekyll_config.sub!(/^subscribe_rss:\s*\/.+$/, "subscribe_rss: #{dir}/atom.xml")
-    jekyll_config.sub!(/^root:.*$/, "root: /#{dir.sub(/^\//, '')}")
+    jekyll_config.sub!(/^destination:.+$/, "destination: #{File.join(tmp_dir, "public", dir)}")
+    jekyll_config.sub!(/^root:.*$/, "root: #{dir}")
     File.open('_config.yml', 'w') do |f|
       f.write jekyll_config
     end
-    rm_rf public_dir
-    mkdir_p "#{public_dir}#{dir}"
-    puts "## Site's root directory is now '/#{dir.sub(/^\//, '')}' ##"
+    puts "## Site's root directory is now '#{dir}' ##"
   end
 end
 
 desc "Set up _deploy folder and deploy branch for Github Pages deployment"
-task :setup_github_pages, :repo do |t, args|
+task :setup_github_pages, [:repo, :yes] do |t, args|
   if args.repo
     repo_url = args.repo
   else
     puts "Enter the read/write url for your repository"
-    puts "(For example, 'git@github.com:your_username/your_username.github.io.git)"
-    puts "           or 'https://github.com/your_username/your_username.github.io')"
+    puts "For example, 'git@github.com:your_username/your_username.github.io.git"
+    puts "             'https://github.com/your_username/repository'"
+    puts "             'https://${GH_TOKEN}@github.com/your_username/repository'"
     repo_url = get_stdin("Repository url: ")
   end
   protocol = (repo_url.match(/(^git)@/).nil?) ? 'https' : 'git'
@@ -322,56 +598,85 @@ task :setup_github_pages, :repo do |t, args|
     user = repo_url.match(/github\.com\/([^\/]+)/)[1]
   end
   branch = (repo_url.match(/\/[\w-]+\.github\.(?:io|com)/).nil?) ? 'gh-pages' : 'master'
-  project = (branch == 'gh-pages') ? repo_url.match(/([^\/]+?)(\.git|$)/i)[1] : ''
+  project = (branch == 'gh-pages') ? repo_url.split("/")[-1].sub(/\.git$/, "") : ''
+  use_token = (repo_url.match(/https:\/\/.*@github.com/))? true : false
+  use_token_val = use_token ? "true" : "false"
   unless (`git remote -v` =~ /origin.+?octopress(?:\.git)?/).nil?
     # If octopress is still the origin remote (from cloning) rename it to octopress
-    system "git remote rename origin octopress"
+    ok_failed("git remote rename origin octopress", false)
     if branch == 'master'
       # If this is a user/organization pages repository, add the correct origin remote
       # and checkout the source branch for committing changes to the blog source.
-      system "git remote add origin #{repo_url}"
-      puts "Added remote #{repo_url} as origin"
-      system "git config branch.master.remote origin"
-      puts "Set origin as default remote"
-      system "git branch -m master source"
-      puts "Master branch renamed to 'source' for committing your blog source files"
-    else
-      unless !public_dir.match("#{project}").nil?
-        system "rake set_root_dir[#{project}]"
+      ok_failed("git remote add origin #{repo_url}", false)
+      if use_token
+        puts "Added given remote as origin"
+      else
+        puts "Added remote #{repo_url} as origin"
       end
+      ok_failed("git config branch.master.remote origin", false)
+      puts "Set origin as default remote"
+      ok_failed("git branch -m master source", false)
+      puts "Master branch renamed to 'source' for committing your blog source files"
     end
   end
   url = blog_url(user, project, source_dir)
   jekyll_config = IO.read('_config.yml')
   jekyll_config.sub!(/^url:.*$/, "url: #{url}")
+  jekyll_config.sub!(/^subscribe_rss:.*$/, "subscribe_rss: #{url}/atom.xml")
+  jekyll_config.sub!(/^feedly_atom:.*$/, "feedly_atom: #{url}/atom.xml")
   File.open('_config.yml', 'w') do |f|
     f.write jekyll_config
   end
-  rm_rf deploy_dir
-  mkdir deploy_dir
-  cd "#{deploy_dir}" do
-    system "git init"
-    system 'echo "My Octopress Page is coming soon &hellip;" > index.html'
-    system "git add ."
-    system "git commit -m \"Octopress init\""
-    system "git branch -m gh-pages" unless branch == 'master'
-    system "git remote add origin #{repo_url}"
-    rakefile = IO.read(__FILE__)
-    rakefile.sub!(/deploy_branch(\s*)=(\s*)(["'])[\w-]*["']/, "deploy_branch\\1=\\2\\3#{branch}\\3")
-    rakefile.sub!(/deploy_default(\s*)=(\s*)(["'])[\w-]*["']/, "deploy_default\\1=\\2\\3push\\3")
-    File.open(__FILE__, 'w') do |f|
-      f.write rakefile
+
+  rakefile = IO.read(__FILE__)
+  rakefile.sub!(/deploy_branch(\s*)=(\s*)(["'])[\w-]*["']/, "deploy_branch\\1=\\2\\3#{branch}\\3")
+  rakefile.sub!(/repo_url(\s*)=(\s*)(["'])[0-9a-zA-Z\-\_\/\@\.\:]*["']/, "repo_url\\1=\\2\\3#{repo_url}\\3")
+  rakefile.sub!(/use_token(\s*)=(\s*)[0-9a-zA-Z\-\_\/\@\.\:]*/, "use_token\\1=\\2#{use_token_val}")
+
+  ext = 'markdown'
+  if ask("Do you want to use 'md' extension instead of 'markdown'?", ['y', 'n'], args.yes) == "y"
+    ext = 'md'
+  end
+  rakefile.sub!(/new_post_ext(\s*)=(\s*)(["'])[\w-]*["']/, "new_post_ext\\1=\\2\\3#{ext}\\3")
+  rakefile.sub!(/new_page_ext(\s*)=(\s*)(["'])[\w-]*["']/, "new_page_ext\\1=\\2\\3#{ext}\\3")
+
+  if ask("Do you want to push_ex (renew remote repository evrey time)?", ['y', 'n'], args.yes) == 'y'
+    if yn_check(args.yes) == "y"
+      dir = ""
+    else
+      dir = get_stdin("Enter where you want to put _deploy (current: #{tmp_dir}): ")
+    end
+    if dir == ""
+      dir = tmp_dir
+    elsif
+      if dir[-1] == "/"
+        dir = dir[0..-2]
+      end
+    end
+    rakefile.sub!(/deploy_default(\s*)=(\s*)(["'])[\w-]*["']/, "deploy_default\\1=\\2\\3push_ex\\3")
+    rakefile.sub!(/(tmp_dir\s*=\s*File.expand_path\()(["'])[^"']*["']/,"\\1\\2#{dir}\\2")
+  else
+    rm_rf deploy_dir
+    mkdir deploy_dir
+    cd "#{deploy_dir}" do
+      ok_failed("git init", false)
+      ok_failed("echo 'My Octopress Page is coming soon &hellip;' > index.html", false)
+      ok_failed("git add -A", false)
+      ok_failed("git commit -m \"Octopress init\"", false)
+      ok_failed("git branch -m #{deploy_branch}", false) unless branch == 'master'
+      ok_failed("git remote add origin #{repo_url}", false)
+      rakefile.sub!(/deploy_default(\s*)=(\s*)(["'])[\w-]*["']/, "deploy_default\\1=\\2\\3push\\3")
+    end
+    if use_token
+      puts "\n---\n## Now you can deploy with `rake deploy` ##"
+    else
+      puts "\n---\n## Now you can deploy to #{repo_url} with `rake deploy` ##"
     end
   end
-  puts "\n---\n## Now you can deploy to #{repo_url} with `rake deploy` ##"
-end
-
-def ok_failed(condition)
-  if (condition)
-    puts "OK"
-  else
-    puts "FAILED"
+  File.open(__FILE__, 'w') do |f|
+    f.write rakefile
   end
+  ok_failed("rake set_root_dir[#{project}]", false)
 end
 
 def get_stdin(message)
@@ -379,9 +684,22 @@ def get_stdin(message)
   STDIN.gets.chomp
 end
 
-def ask(message, valid_options)
+def yn_check(yn)
+  if yn == "y" or yn == "yes" or yn == "-y" or yn == "--yes"
+    answer = "y"
+  else
+    answer = "n"
+  end
+  answer
+end
+
+def ask(message, valid_options, yn = "")
   if valid_options
-    answer = get_stdin("#{message} #{valid_options.to_s.gsub(/"/, '').gsub(/, /,'/')} ") while !valid_options.include?(answer)
+    if valid_options.include?("y") and yn_check(yn) == "y"
+      answer = "y"
+    else
+      answer = get_stdin("#{message} #{valid_options.to_s.gsub(/"/, '').gsub(/, /,'/')}: ") while !valid_options.include?(answer)
+    end
   else
     answer = get_stdin(message)
   end
@@ -390,10 +708,10 @@ end
 
 def blog_url(user, project, source_dir)
   cname = "#{source_dir}/CNAME"
-  url = if File.exists?(cname)
-    "http://#{IO.read(cname).strip}"
+  url = if File.exist?(cname)
+    "https://#{IO.read(cname).strip}"
   else
-    "http://#{user.downcase}.github.io"
+    "https://#{user.downcase}.github.io"
   end
   url += "/#{project}" unless project == ''
   url
@@ -404,3 +722,343 @@ task :list do
   puts "Tasks: #{(Rake::Task.tasks - [Rake::Task[:list]]).join(', ')}"
   puts "(type rake -T for more detail)\n\n"
 end
+
+def grep_check(word, grep_option, opt)
+  vword=word
+  if word.index("^") == 0
+    vword=word.sub("^", ":")
+  end
+  if opt == 0
+    grep_option = "-A1 -B1 #{grep_option}"
+    comment = "An empty line is required around \\\"#{word}\\\"!"
+  elsif opt == 1
+    grep_option = "-B1 #{grep_option}"
+    comment = "An empty line is required before \\\"#{word}\\\"!"
+  elsif opt == 2
+    grep_option = "-A1 #{grep_option}"
+    comment = "An empty line is required after \\\"#{word}\\\"!"
+  end
+  print "Checking \"#{word}\"... "
+  ok_failed("\
+      if grep -H -n -e \"#{word}\" #{grep_option} 2>/dev/null|\
+          grep -v \"#{vword}\";then \
+        printf \"\\\\n\\\\e[31m\";\
+        echo #{comment};\
+        printf \"\\\\e[m\\\\n\";\
+        exit 1;\
+      fi", false)
+end
+
+desc 'Check source'
+task :check, :opt do |t, args|
+  grep_files = "-r #{source_dir} --include \"*.#{new_post_ext}\""
+  if args.opt == "new"
+    grep_files = "#{source_dir}/#{posts_dir}/*.#{new_post_ext}"
+  end
+  puts "\n## Checking codes..."
+  grep_option = "#{grep_files}|\
+      grep -v \"^--$\"|\
+      grep -v \"#{new_post_ext}-[0-9]\\\+-$\"|\
+      grep -v \"{%\ *raw\ *%}$\""
+
+  grep_check("^{%\ *codeblock", grep_option, 1)
+  #grep_check("^>", grep_option, 0)
+  #grep_check("^#", grep_option, 1)
+  grep_check("^- - -$", grep_option, 1)
+  #grep_check("^<hr>$", grep_option, 1)
+
+  print "Checking words to be avoided... "
+  ok_failed("\
+      if [ -f #{word_avoid} ];then \
+        while read a;do \
+          if ret=$(grep -i -q $a #{grep_files} 2>/dev/null);then \
+            echo \"A word $a is included, must be avoided!!!\";\
+            echo $ret;\
+            exit 1;\
+          fi;\
+        done < #{word_avoid};\
+      fi", false)
+  puts ""
+end
+
+desc 'Send to Superfeedr'
+task :superfeedr do
+  site_config = YAML.load(IO.read('_config.yml'))
+  hub_url = site_config['hub_url']
+  url = site_config['url']
+  if hub_url != nil and hub_url != ""
+    require 'net/http'
+    require 'uri'
+    atom_url = "#{url}/atom.xml"
+    resp, data = Net::HTTP.post_form(URI.parse(hub_url),
+        {'hub.mode' => 'publish',
+        'hub.url' => atom_url})
+    raise "!! Hub notification error: #{resp.code} #{resp.msg}, #{data}" unless resp.code == "204"
+    puts "## Notified hub (" + hub_url + ") that feed #{atom_url} has been updated"
+  end
+end
+
+#desc 'Ping pingomatic'
+#task :ping do
+#  begin
+#    require 'xmlrpc/client'
+#    puts '* Pinging ping-o-matic'
+#    XMLRPC::Client.new('rpc.pingomatic.com', '/').call('weblogUpdates.extendedPing', 'Nothoughtcontrol.com' , 'https://www.nothoughtcontrol.com', 'https://www.nothoughtcontrol.com/atom.xml')
+#  rescue LoadError
+#    puts '! Could not ping ping-o-matic, because XMLRPC::Client could not be found.'
+#  end
+#end
+#
+#desc 'Notify Google of the new sitemap'
+#task :sitemapgoogle do
+#  begin
+#    require 'net/http'
+#    require 'uri'
+#    puts '* Pinging Google about our sitemap'
+#    Net::HTTP.get('www.google.com', '/webmasters/tools/ping?sitemap=' + URI.escape('https://www.nothoughtcontrol.com/sitemap.xml'))
+#  rescue LoadError
+#    puts '! Could not ping Google about our sitemap, because Net::HTTP or URI could not be found.'
+#  end
+#end
+#
+#desc 'Notify Bing of the new sitemap'
+#task :sitemapbing do
+#  begin
+#    require 'net/http'
+#    require 'uri'
+#    puts '* Pinging Bing about our sitemap'
+#    Net::HTTP.get('www.bing.com', '/webmaster/ping.aspx?siteMap=' + URI.escape('https://www.nothoughtcontrol.com/sitemap.xml'))
+#  rescue LoadError
+#    puts '! Could not ping Bing about our sitemap, because Net::HTTP or URI could not be found.'
+#  end
+#end
+#
+#desc "Notify various services about new content"
+#task :notify => [:pingomatic, :sitemapgoogle, :sitemapbing] do
+#end
+#
+
+#desc 'Ping PINGOO'
+#task :ping do
+#  begin
+#    require 'xmlrpc/client'
+#    puts '* Pinging PINGOO{'
+#    XMLRPC::Client.new('pingoo.jp', '/').call('weblogUpdates.extendedPing', 'rcmdnk.com' , 'https://rcmdnk.com', 'https://rcmdnk.com/atom.xml')
+#  rescue LoadError
+#    puts '! Could not ping PINGOO, because XMLRPC::Client could not be found.'
+#  end
+#end
+
+#desc 'Ping pingomatic'
+#task :ping do
+#  begin
+#    require 'xmlrpc/client'
+#    puts '## Pinging PINGOO'
+#    #XMLRPC::Client.new('rpc.pingomatic.com', '/').call('weblogUpdates.extendedPing', 'rcmdnk\'s blog' , 'https://rcmdnk.com', 'https://rcmdnk.com/atom.xml')
+#    XMLRPC::Client.new2('https://api.my.yahoo.co.jp/RPC2').call('weblogUpdates.ping', 'rcmdnk blog' , 'https://rcmdnk.com')
+#  rescue LoadError
+#    puts '! Could not ping ping-o-matic, because XMLRPC::Client could not be found.'
+#  end
+#end
+#
+
+#-- sending ping --#
+desc "Send ping to Web Search Engines"
+task :ping do
+  if File.exist?(ping_file)
+    require "yaml"
+    require "xmlrpc/client"
+
+    site_config = YAML.load(IO.read('_config.yml'))
+    blog_title = site_config['title']
+    blog_url = site_config['url']
+    ping_url = YAML.load(IO.read('ping.yml'))
+    ping_url.each do |url|
+      ping = XMLRPC::Client.new2(url)
+      begin
+        result = ping.call('weblogUpdates.ping', blog_title, blog_url)
+        puts "#{url} : #{result}"
+      rescue => e
+        puts "#{url} : #{e}"
+      end
+    end
+  end
+end
+
+task :test do
+  #ok_failed("if [ -f #{word_avoid} ];then while read a;do if ret=`grep -i -r -q $a #{public_dir}`;then echo \"A word $a is included, must be avoided!!!\"; echo $ret; exit 1;fi; done < #{word_avoid};fi", false)
+  #ok_failed("cd #{public_dir};pwd;cd -", false)
+  #raise "eror"
+  ok_failed("git ls >& log", false)
+end
+
+def ok_failed(command, print_ok = false)
+  out, err, status = Open3.capture3(command)
+  if (status.success?)
+    if print_ok
+      puts "=== command ==="
+      puts command
+      puts "=== stdout ==="
+      puts out
+      puts "=== stderr ==="
+      puts err
+      puts "OK" if print_ok
+    end
+  else
+    puts "=== command ==="
+    puts command
+    puts "=== stdout ==="
+    puts out
+    puts "=== stderr ==="
+    puts err
+    raise "FAILD"
+  end
+end
+
+require "yui/compressor"
+require "htmlcompressor"
+require "parallel"
+
+desc "Minify CSS"
+task :minify_css do
+  puts "## Minifying CSS"
+  compressor = YUI::CssCompressor.new
+  Parallel.map(Dir.glob("#{source_dir}/stylesheets/**/*css"), :in_threads=> n_cores) do |name|
+    puts "Minifying #{name}"
+    input = File.read(name)
+    output = File.open("#{name}", "w")
+    output << compressor.compress(input)
+    output.close
+  end
+  cp_r "#{source_dir}/stylesheets/.", "#{public_dir}/stylesheets/"
+end
+
+desc "Minify JS"
+task :minify_js, :opt do |t, args|
+  puts "## Minifying JS"
+  if js_minify_others
+    Rake::Task[:minify_other_js].invoke(args.opt)
+  end
+end
+
+desc "Minify JS and combine"
+task :combine_js, :opt do |t, args|
+  puts "## Combining JS"
+  compressor = YUI::JavaScriptCompressor.new
+  if not args.opt == nil and (not args.opt and File.exist?("#{source_dir}/javascripts/#{js_output}"))
+    t_alljs = File.mtime("#{source_dir}/javascripts/#{js_output}")
+    time_check = false
+    js_for_combine.each do |j|
+      if File.mtime("#{source_dir}/javascripts/#{j}") > t_alljs
+        puts "newer file #{j} is found"
+        time_check = true
+        break
+      end
+    end
+    if not time_check
+      next
+    end
+  end
+  output = File.open("#{source_dir}/javascripts/#{js_output}", "w")
+  js_for_combine.each do |j|
+    input = File.read("#{source_dir}/javascripts/#{j}")
+    if args.opt == nil or args.opt.include?("no") or args.opt.include?("test")
+      output << input
+    else
+      output << compressor.compress(input)
+    end
+  end
+  output.close
+  cp_r "#{source_dir}/javascripts/#{js_output}", "#{public_dir}/javascripts/"
+end
+
+desc "Minify other JS"
+task :minify_other_js, :opt do |t, args|
+  puts "## Minifying other JS"
+  n = 0
+  compressor = YUI::JavaScriptCompressor.new
+  Parallel.map(Dir.glob("#{source_dir}/javascripts/**/*.js"), :in_threads => n_cores)  do |j|
+    if (js_for_combine+[js_output]).include?(j.sub("#{source_dir}/javascripts/", "")) or\
+       j.include?("compressed")
+      next
+    end
+    dir = j.split('/')[0..-2].join('/')
+    name = j.split('/')[-1]
+    compressed = dir + "/compressed/" + name
+    if File.directory?(dir+"/compressed/")
+      if not args.opt == nil and (not args.opt and File.file?(compressed) and File.mtime(compressed) > File.mtime(j))
+        next
+      end
+    else
+      mkdir_p compressed.split('/')[0..-2].join('/')
+    end
+
+    puts "Minifying #{j}"
+    input = File.read(j)
+    output = File.open(compressed, "w")
+    if args.opt and args.opt.include?("no")
+      output << input
+    else
+      output << compressor.compress(input)
+    end
+    output.close
+    n+=1
+  end
+  if n > 0
+    cp_r "#{source_dir}/javascripts/.", "#{public_dir}/javascripts/"
+  end
+end
+
+desc "Minify HTML"
+task :minify_html do
+  puts "## Minifying HTML"
+
+  option={
+     :remove_comments => false,
+     :compress_css => true,
+     :css_compressor => :yui,
+     :compress_javascript => true,
+     :javascript_compressor => :yui
+  }
+  compressor = HtmlCompressor::Compressor.new(option)
+
+  posts = []
+  if html_for_minify == "all" or html_for_minify[0] == "all"
+    posts = Dir.glob("#{public_dir}/**/*.html")
+  else
+    posts_tmp = html_for_minify
+    if html_for_minify.is_a?(String)
+      posts_tmp = [posts_tmp]
+    end
+    posts_tmp.each do |p|
+      f = "#{public_dir}/#{p}"
+      if f.scan("\*").length > 0
+        posts += Dir.glob(f)
+      elsif File.file?(f)
+        posts.push(f)
+      elsif File.directory?(f)
+        posts += Dir.glob("#{f}/**/*.html")
+      end
+    end
+  end
+  if html_not_minify != nil
+    if html_not_minify.is_a?(String)
+      html_not_minify = [html_not_minify]
+    end
+    html_not_minify.each  do |p|
+      posts.delete_if {|post| post.start_with?("#{public_dir}/#{p}")}
+    end
+  end
+
+  progressbar = ProgressBar.create(:title => "Minify HTML", :starting_at => 0,
+                                   :total => posts.size,
+                                   :format => '%t, %a |%b%i| %p%')
+  Parallel.map(posts, :in_threads => n_cores)  do |p|
+    input = File.read(p)
+    output = File.open(p, "w")
+    output << compressor.compress(input)
+    output.close
+    progressbar.increment
+  end
+end
+
